---
title: "GEOG 6000 Lab 11 Spatial modeling with INLA"
author: "Simon Brewer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    fig_caption: true
    css: "../style.css"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,
                      error = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center")

```

# Introduction

```{r echo=FALSE}
set.seed(1234)
library(png)
library(grid)
```

This lab provides a fairly brief introduction to using [INLA][1] for Bayesian analysis in R. The first section will cover using INLA for non-spatial models (LMs, GLMS and mixed-effects models),. We'll then go on to look at using INLA for spatial regression models. In addition to INLA, R has a large number of add-on packages for Bayesian analysis listed [here][2]. Some notable ones are:

- **coda**: provides routines for post-processing results
- **mcmcplots**: provides prettier visualizations of MCMC results
- **MCMCpack**: provides mainly standard statistical models in a simpler format
- **rstan**: interface to the Stan modeling language
- **brms**: simplified interface to Stan

Before starting the lab, you will need to set up a new folder for your working directory. Go to your `geog6000` folder now and create a new folder for today's class called `lab11`. 

You'll need the following files:

- The GapMinder dataset: *gapminderData5.csv*
- A dataset from a study of Irish schoolchildren *irished.csv*
- A dataset of UFO sightings for US States *nuforc.zip*

You will need to download these files from Canvas, and move them from your `Downloads` folder to the `datafiles` folder that you made previously. 

Now start RStudio and change the working directory to `lab11`. As a reminder, you can do this by going to the [Session] menu in RStudio, then [Change working directory]. This will open a file browser that you can use to browse through your computer and find the folder. 

## Installing INLA

The INLA package is not available through the usual CRAN repositories. Instead, you'll need to install this manually. The following code will install the current stable version of INLA:

```{r eval=FALSE}

install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)

```

Once this is installed, we can load the libraries that we'll need for this lab

```{r message=FALSE}

library(dplyr)
library(ggplot2)
library(lme4)
library(sf)
library(INLA)
library(spdep)
library(tmap)

```

```{r echo=FALSE, message=FALSE}

load("inla_models.RData")

```

# Non-spatial models

## Linear regression

We'll start by using INLA to build a simple linear regression model of life expectancy (`lifeExp`) as a function of per capita GDP (`gpdPercap`) from the GapMinder data. Start by a) loading the data; b) centetring the years on 1952; and c) log transforming GDP (to check why we do this last step, try making a histogram of the untransformed and transformed GDP values). 

```{r}

gap <- read.csv("../datafiles/gapminderData5.csv")
gap$year2 <- gap$year - 1952
gap$gdpPercap2 <- log(gap$gdpPercap)

```

Next, make an OLS regression model using `lm()` as a comparison. With the increasing complexity of Bayesian models, it is quite useful to make a traditional model as a verification that your results are correct. In the `summary()`, take note of the coefficients, and the residual standard error (this is an estimate of how much residual variance you have)

```{r}

fit_lm <- lm(lifeExp ~ gdpPercap2, gap)
summary(fit_lm)

```

Now let's set up our INLA model. For this simple model, it's pretty straightforward if we just use the default priors:

```{r eval = FALSE}

inla_lm <- inla(lifeExp ~ gdpPercap2, 
                data = gap)

```

By default, the INLA model will not calculate any model diagnostics (to make it as efficient as possible), so we can add the following arguments to get a) WAIC and DIC scores and b) model estimates of life expectancy for each observation:

```{r eval = FALSE}

inla_lm <- inla(lifeExp ~ gdpPercap2, 
                data = gap,
                control.compute = list(dic = TRUE, waic = TRUE),
                control.predictor = list(compute = TRUE))

```

If you want to see some of the detail of INLA working, add `verbose=TRUE` to the `inla()` function. Now let's look at the output

```{r}

summary(inla_lm)

```

And there's quite a lot. Note there is a table of fixed effects with the intercept and slope estimates, the WAIC and DIC, and the precision value. To show only the fixed effects, 

```{r}

inla_lm$summary.fixed

```

Note that as this is a Bayesian model, we don't get a standard error and $p$-value, instead we get a description of the posterior distribution of each coefficient, so the summary gives the mean, median, mode, s.d. and the 2.5 and 97.5 percentiles (`0.025quant` and `0.975quant`). As a quick rule of thumb, if these percentiles have the same sign, we can assume that there is a *credible* effect (note the difference in language here). You can get a quick plot of these posterior distributions with INLA's `plot()` function. By default, this will try to plot everything from the model, so it is easier to only select the fixed effects for now:

```{r eval = FALSE}

plot(inla_lm, plot.fixed.effects = TRUE,
     plot.random.effects = FALSE,
     plot.hyperparameters = FALSE,
     plot.predictor = FALSE)

```

```{r fig.width=6.5, fig.height=4., echo=FALSE}
img <- readPNG("inla.plots/lm-1.png")
grid.raster(img)
```

In the linear model, we got an estimate of the residual standard deviation of around 7.6. This is a measure of the size of the errors from the model. In the INLA output, we get an estimate of the residual precision instead, which is the inverse of the variance. You can extract this with:

```{r}

inla_lm$summary.hyperpar

```

To compare, we can invert this and take the squre root to convert back to standard deviation units, and to check that the models are estimating the same value:

```{r}

sqrt(1 / 0.0172)

```

Which matches the estimate from the `lm()` function. And we can plot the posterior distribution:

```{r eval=FALSE}

plot(inla_lm, plot.fixed.effects = FALSE,
     plot.random.effects = FALSE,
     plot.hyperparameters = TRUE,
     plot.predictor = FALSE)

```

```{r fig.width=6.5, fig.height=4., echo=FALSE}
img <- readPNG("inla.plots/lm-2.png")
grid.raster(img)
```

As INLA calculated the Bayesian posterior estimates for each observation, we can compare these to the observed life expectancies. The posterior estimates are in:

```{r results='hide'}

inla_lm$summary.linear.predictor

```

We'll just plot the mean of these predictions against the observations:

```{r}

plot(gap$lifeExp, inla_lm$summary.linear.predictor$mean)
abline(0,1)

```

## Generalized models

In the next example, we'll build a generalized linear model (GLM) using the Irish education dataset. In this dataset, we are interested in modeling the probability of a student taking the leaving certificate (`lvcert`) using a verbal reasoning score (`DVRT`). Load the data and center the DVRT scores:

```{r}

irished <- read.csv("../datafiles/irished.csv")
irished$DVRT.cen <- irished$DVRT - mean(irished$DVRT)

```

Build a standard `glm` for comparison:

```{r}

fit_glm <- glm(lvcert ~ DVRT.cen, 
               data = irished, 
               family = binomial(link = 'logit'))

summary(fit_glm)

```

Again, note the coefficient estimates. Now let's build the same model with INLA. Here, we simply specify the `family` argument (the default is `gaussian`), and use the same arguments as before to estimate model diagnostics:

```{r eval=FALSE}
inla_glm <- inla(lvcert ~ DVRT.cen, 
                 data = irished, 
                 family = "binomial",
                 control.compute = list(dic = TRUE, waic = TRUE),
                 control.predictor = list(compute = TRUE))
summary(inla_glm)
```

```{r echo=FALSE}
summary(inla_glm)
```

As before, we can plot out the posterior distributions of the intercept and slope. How do these compare to the `glm` output?

```{r}

plot(inla_glm, plot.fixed.effects = TRUE,
     plot.random.effects = FALSE,
     plot.hyperparameters = FALSE,
     plot.predictor = FALSE)

```

Note that there is no separate estimate of residual variance in a binomial model. 

## Mixed-effects models

Next, we'll estimate a mixed-effects model for the Gap Minder data, with a random intercept. First, we'll build a comparison model using `lmer()` from the **lme4** package. We'll again model the trend of life expectancy over time within the dataset as a linear fixed effect:

```{r}

fit_lmer <- lmer(lifeExp ~ year2 + (1 | country), gap)
summary(fit_lmer)

```

In INLA, additional random effects can be added with the `f()` function. These include a large number of effects, including groups (as here) and spatial and temporal effects (see below). The format is `f(ID, model)`, where `ID` is an index in the data set identifying groups or other structures and `model` is the type of random effect. Here, we'll use the `iid` model with assumes that model errors are i.i.d. within countries. 

```{r eval=FALSE}

inla_lmer <- inla(lifeExp ~ year2 + f(country, model = "iid"), 
                  data = gap,
                 control.compute = list(dic = TRUE, waic = TRUE),
                 control.predictor = list(compute = TRUE))

```

```{r}

summary(inla_lmer)

```

Check that the fixed effects are similar to those from `lmer()`. Agai, you can plot these:

```{r eval=FALSE}

plot(inla_lmer, plot.fixed.effects = TRUE,
     plot.random.effects = FALSE,
     plot.hyperparameters = FALSE,
     plot.predictor = FALSE)

```

```{r fig.width=6.5, fig.height=4., echo=FALSE}
img <- readPNG("inla.plots/lmer-1.png")
grid.raster(img)
```

If we plot the hyperparameters, we now get the posterior distribution for the residual variance and the variance explained by the random intercepts. 

```{r eval=FALSE}

plot(inla_lmer, plot.fixed.effects = FALSE,
     plot.random.effects = FALSE,
     plot.hyperparameters = TRUE,
     plot.predictor = FALSE, 
     plot.prior = TRUE)

```

```{r fig.width=6.5, fig.height=4., echo=FALSE}
img <- readPNG("inla.plots/lmer-3.png")
grid.raster(img)
```

We can compare these by extracting these values and back converting to variance. First, the `lmer()` effects

```{r}

VarCorr(fit_lmer)

```

```{r}

inla_lmer$summary.hyperpar

# Residual s.d.
sqrt(1 / 0.078)
# Intercept s.d.
sqrt(1 / 0.0082)

```

We can get the random effect for any country (the offset from the grand mean intercept). These are in `inla_lmer$summary.random`. Each row has the country name (this was the index used in the `f()` function) as well as the summary of the posterior distribution for that country. To find the random effect for Japan:

```{r}

rowid <- which(inla_lmer$summary.random$country == "Japan")
inla_lmer$summary.random$country[rowid, ]

```
Indicating that Japan's life expectancy is about 15 years above the global average over the period Gap observations, and the 2.5 and 97.5 percentile indicate that this is credible higher than average. We can also plot the marginal distribution of this estimate (this is the distribution), by extracting the relevant values from the `inla_lmer$marginals.random`:

```{r}

japan_re <- inla_lmer$marginals.random$country[[rowid]]
plot(japan_re, type = 'l', xlab = "LifeExp", ylab = "p")

```

# Spatial models

We'll now turn to building spatial models with INLA. In the *nuforc.zip* file there is a shapefile with the counts of UFO sightings for US states between 1990 and 2019. Let's load this now:

```{r}

ufos <- st_read("../datafiles/nuforc/ufo_sf_annual.shp")

```

```{r echo=FALSE}
load("ufo_models.RData")
```

This contains quite a lot of information, but our models, we'll need the count data (`count`) and the population size. We'll subset out only 2014 using **dplyr** (you can also do this with `ufos_2014 <- subset(ufos, year == 2014)`):

```{r}

ufos_2014 <- ufos %>%
  filter(year == 2014)

```

And now use **tmap** to map out the counts and population size:

```{r}

p1 <- tm_shape(ufos_2014) + tm_fill("count", style = "jenks") +
  tm_borders() +
  tm_layout(main.title = "UFO sightings 2014")

p2 <- tm_shape(ufos_2014) + tm_fill("population", style = "jenks") +
  tm_borders() +
  tm_layout(main.title = "State population 2014")

tmap_arrange(p1, p2)

```

We'll start with a simple model of the count of sightings as a function of population size. We'll use this as a demonstration, even though the outcome are counts, and a Poisson model would be a better approach (we'll get to this shortly). 

```{r}

ufo_lm <- lm(count ~ population, ufos_2014)
summary(ufo_lm)

```

And now we'll build the same using INLA:

```{r eval=FALSE}

ufo_inla_lm <- inla(count ~ population,
                    data = ufos_2014,
                    control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE),
                    control.predictor = list(compute = TRUE))

```

Let's check the coefficients against the OLS model:

```{r}

ufo_inla_lm$summary.fixed

```

We'll now plot the posterior distribution of the coefficents and the estimate of the residual variance. Rather than using INLA's `plot()` function, we'll get the values directly from the model output and plot them. The posterior distribution of the fixed effects can be obtained from:

```{r results='hide'}

ufo_inla_lm$marginals.fixed

```

And the residual variance from:

```{r results='hide'}

ufo_inla_lm$marginals.hyperpar

```

- Plot posterior distribution of intercept

```{r}

plot_df <- as.data.frame(inla.tmarginal(function(x) x, 
                                        ufo_inla_lm$marginals.fixed$`(Intercept)`))
ggplot(plot_df, aes(x = x, y = y)) +
  geom_line(size = 2) +
  scale_x_continuous("Intercept") +
  scale_y_continuous("P") +
  theme_bw()

```

- Plot posterior distribution of population coefficient

```{r}

plot_df <- as.data.frame(inla.tmarginal(function(x) x, 
                                        ufo_inla_lm$marginals.fixed$population))
ggplot(plot_df, aes(x = x, y = y)) +
  geom_line(size = 2) +
  scale_x_continuous("Population") +
  scale_y_continuous("P") +
  theme_bw()

```

- Plot posterior distribution of residual variance

```{r}

plot_df <- as.data.frame(inla.tmarginal(function(x) 1/x, 
                                        ufo_inla_lm$marginals.hyperpar$`Precision for the Gaussian observations`))
ggplot(plot_df, aes(x = x, y = y)) +
  geom_line(size = 2) +
  scale_x_continuous("Residual variance") +
  scale_y_continuous("P") +
  theme_bw()

```

Just as an example, the following code adds informed priors on the slope and intercept coefficient, by increasing the precision of the prior (effectively reducing the variance or range of values). The mean of the priors is left at zero. Try running this and compare the estimates of coefficients and the WAIC/DIC goodness of fit values.

```{r eval = FALSE}

ufo_inla_lm2 <- inla(count ~ population,
                     data = ufos_2014,
                     control.fixed = list(mean = 0, prec = 0.2, 
                                          mean.intercept = 0, prec.intercept = 0.2),
                     control.family=list(hyper=list(prec = list(prior = 'loggamma', 
                                                              param = c(0.1, 0.1)))),
                     control.compute = list(dic = TRUE, waic = TRUE),
                     control.predictor = list(compute = TRUE))

```

```{r}

summary(ufo_inla_lm2)

```

## Spatial neighborhood and weight matrix

We'll use a conditional autoregressive (CAR) model to account for spatia dependency in the UFO data. This is a very similar approach to the spatial error model we looked at in a previous lab. In INLA, this means adding a new random effect to the model using the `f()` function. There's a few things we need to do to set this up:

- Create an index in the dataset (this will be linked to the spatial weight matrix)

```{r}

ufos_2014$idarea <- 1:nrow(ufos_2014)

```

- Create a neighborhood structure (here we use the `poly2nb()` function from **spdep**)

```{r}

ufos_nb <- poly2nb(ufos_2014)

```

- Convert the enighborhood structure to a spatial weight matrix

```{r}

ufos_W <- nb2mat(ufos_nb)

```

Quick plot of the spatial adjacencies:

```{r}

plot(st_geometry(ufos_2014), reset = FALSE)
plot(ufos_nb, st_coordinates(st_centroid(ufos_2014)), add = TRUE, col = 2, lwd = 2)

```

With all that in place, we can build a spatial model. We'll use the newer `bym2` formulation of the CAR model. Note that the format is similar to specifying a random effect above: we need the index (`idarea`), the model (`bym2`) and the spatial weight matrix:

```{r eval=FALSE}

ufo_inla_bym <- inla(count ~ population + f(idarea, model = "bym2", graph = ufos_W), 
                     data = ufos_2014,
                     control.compute = list(dic = TRUE, waic = TRUE),
                     control.predictor = list(compute = TRUE)
)

```

Now let's look at the output:

```{r}

summary(ufo_inla_bym)

```

The main change to the output is that we now have three hyperparameter values:

- `Precision for the Gaussian observations`: this is the precision on the non-spatial residuals
- `Precision for idarea`: this is the precision on the spatial field
- `Phi for idarea`: this is the mixing parameter, which decomposes the precision for `idarea` into a spatial and non-spatial effect. 

Note that the precision for the Gaussian term is very high (the variance is low). This is likely not very well constrained, so we'll try to add a prior on the spatial random effect to improve this. Here we specify a penalized complexity prior - note that we need one for the precision term and one for `phi`. The format for these priors is given by $(U, \alpha)$, where $\alpha$ is the probability of the hyperparameter $\xi$ exceeding $U$: ($P(T(\xi) > U) = \alpha$)

```{r}

prior_bym2 <- list(
  prec = list(
    prior = "pc.prec",
    param = c(1, 0.01)),
  phi = list(
    prior = "pc",
    param = c(0.5, 2 / 3))
)

```

And let's rebuild the model:

```{r eval = FALSE}

ufo_inla_bym2 <- inla(count ~ population + f(idarea, model = "bym2", 
                                            graph = ufos_W,
                                            hyper = prior_bym2), 
                     data = ufos_2014,
                     control.compute = list(dic = TRUE, waic = TRUE),
                     control.predictor = list(compute = TRUE),
                     control.inla = list(strategy = "adaptive",int.strategy = "eb")
)

```

```{r}

ufo_inla_bym2$summary.hyperpar

```

These look a little better (or at least more consistent). From the results we can map out the spatial effect. This is the random effect in space as modeled by the `bym2` model. Summary values are held in `ufo_inla_bym2$summary.random$idarea`. Note that only the first 49 values here represent the spatial random field:


```{r}

ufos_2014$u <- ufo_inla_bym2$summary.random$idarea$mean[1:49]
tm_shape(ufos_2014) + tm_fill("u", style = "jenks") +
  tm_borders() +
  tm_layout(main.title = "UFO model spatial random effect")

```

We can also extract the Bayesian estimates of the number of sightings from `summary.linear.predictor`:

```{r}

ufos_2014$yhat <- ufo_inla_bym2$summary.linear.predictor$mean
tm_shape(ufos_2014) + tm_fill("yhat", style = "jenks") +
  tm_borders() +
  tm_layout(main.title = "State population 2014")

```

## Rate model

We noted above that as our outcome variable is the count of sightings, a Poisson model would be a better choice. We can convert out model to use a Poisson distribution by adding the argument `family = "poisson"` (similar the the binomial model we looked at earlier). However, for these data, we may want to model them as rates, rather than as counts. A reasonable expectation for the count of something is that it will depend on the size of the underlying population. In this example, the number of sightings is strongly correlated with the population size of the each state (this is basically what we modeled in the previous section). Modeling rates means that we can investigate if the *rate* of sightings on a per capita basis is relatively higher or lower than the expected number of counts, if all states were equal. This gives us a model of *relative rates*. In a classic Poisson model, we model the log of counts ($Y_i$) as a function of covariates:

\[
log(Y_i) \sim \beta X_i + \epsilon
\]

In a relative rate model, the observed count ($Y_i$) for location $i$ is defined as the expected 
count for $i$ multiplied by the relative rate ($\theta_i$):

\[
Y_i \sim Pois(E_i \theta_i) 
\]

And then we model the log of the rate term:

\[
log(\theta_i) = \beta X_i + \epsilon
\]

To model this with INLA, we first need to estimate the expected value ($E_i$), the number of sightings in each state if all states have the same rate. We'll do this in a two step process. First, calculate the rate ($r_s$) in the standard population. This is given by the total number of sightings in the data, divided by the total population:

```{r}

rs <- sum(ufos_2014$count) / sum(ufos_2014$population)
rs

```

This gives the per capita rate of UFO sightings for the US (about 1 in 400). Now to get $E_i$ for each state, multiply the state population by this number:

```{r}

ufos_2014$Ei <- ufos_2014$population * rs

```

We'll also redefine the priors for the spatial model:

```{r}

prior_bym2 <- list(
  prec = list(
    prior = "pc.prec",
    param = c(0.6 / 0.31, 0.01)),
  phi = list(
    prior = "pc",
    param = c(0.005, 1 / 10))
)

```

With this information, we can now build our model. We'll start by simply modeling the counts with an intercept term. We specify the family as `poisson` and add the argument `E` to define the expected counts. We again include the `bym2` model for the spatial effects. The final argument (`control.inla`) speeds up the calculation of the hyperparameters at the cost of some accuracy. You can ignore this. 

```{r eval=FALSE}

ufo_inla_rr <- inla(count ~ 1 + f(idarea, model = "bym2", 
                           graph = ufos_W,
                           hyper = prior_bym2), 
             data = ufos_2014, family = "poisson", E = Ei, 
             control.compute = list(dic = TRUE, waic = TRUE),
             control.predictor = list(compute = TRUE),
             control.inla = list(strategy = "adaptive",int.strategy = "eb")
)

```

```{r}

summary(ufo_inla_rr)

```

As before, we can extract and plot the spatial random field

```{r}

ufos_2014$u <- ufo_inla_rr$summary.random$idarea$mean[1:49]
tm_shape(ufos_2014) + tm_fill("u", style = "jenks") +
  tm_borders() +
  tm_layout(main.title = "UFO model spatial random effect (RR model)")

```

In addition, we can plot the estimated relative rates for each state from the summary of the fitted values:

```{r}

ufos_2014$RR <- ufo_inla_rr$summary.fitted.values[, "mean"]
tm_shape(ufos_2014) + tm_fill("RR", palette = "-inferno") +
  tm_borders() +
  tm_layout(main.title = "UFO sightings (relative rates)")

```

Lastly, we can estimate excedence probabilities. This is the probability that a given location has a relative rate that exceeds a given threshold. To estimate this, we need the marginal posterior distribution of relative rates for each state. To illustrate how this works, we'll first extract the posterior distribution for Oregon.

```{r}

rowid <- which(ufos_2014$name == "Oregon")
mpd <- ufo_inla_rr$marginals.fitted.values[[rowid]]
plot(mpd, type = 'l', xlab = "RR", ylab = "p")
abline(v = 2, lty = 2)

```
To get the probability of exceeding a relative rate of 2, we need to calculate the integral to the right hand side of the vertical line in the figure above. INLA comes with a function (`inla.pmarginal()`) that will do this for us. As this calculates the integral to the left hand side, we subtract the result from 1 to get the excedence probability

```{r}
1 - inla.pmarginal(q = 2, marginal = mpd)
```

Giving a `r round(1 - inla.pmarginal(q = 2, marginal = mpd), 2)` probability that sightings in Oregon exceed 2x the national average. Note that this function can also be used to estimate the credibility of coefficients being higher or lower than some threshold. We'll now use R's `sapply()` function to calculate this for all states, and map the results:

```{r}

ufos_2014$exc <- sapply(ufo_inla_rr$marginals.fitted.values,
                        function(marg){1 - inla.pmarginal(q = 2, marginal = marg)})

tm_shape(ufos_2014) + tm_fill("exc", palette = "Blues") +
  tm_borders() +
  tm_layout(main.title = "Excedence probability (RR > 2)")

```
For a final model, we'll add a covariate to our relative rate model, to see if there is a credible link to the rates of sightings. Here, we'll load a data set with the number of airports per state, to test if the number of sightings is linked to this (and by extension the number of flights). Load this and log transform the number of airports. 

```{r}
airports <- read.csv("../datafiles/nuforc/airports.csv")
airports$lairports <- log(airports$airports)
```

Now, we'll merge this with the 2014 UFO dataframe:

```{r}

ufos_2014 <- merge( ufos_2014, airports, by.x = "postal", by.y = "state")
ggplot(ufos_2014, aes(x = airports, y = count)) +
  scale_x_log10("Airports") + scale_y_log10("Sightings") +
  geom_point()

```

```{r eval=FALSE}

ufo_inla_rr2 <- inla(count ~ lairports + 
               f(idarea, model = "bym2", 
                 graph = ufos_W,
                 hyper = prior_bym2), 
             data = ufos_2014, family = "poisson", E = Ei, 
             control.compute = list(dic = TRUE, waic = TRUE),
             control.predictor = list(compute = TRUE),
             control.inla = list(strategy = "adaptive",int.strategy = "eb")
)

```

```{r}

summary(ufo_inla_rr2)

```

And we'll finish by plotting the posterior distribution of the coefficient for the log number of airports:

```{r}
plot_df <- as.data.frame(ufo_inla_rr2$marginals.fixed$lairports)

ggplot(plot_df, aes(x = x, y = y))  +
  geom_line(size = 2) +
  scale_x_continuous("log(Airports)") +
  scale_y_continuous("p") +
  theme_bw()

```
# Files used in lab

## Irish Education data set: *irished.csv*
| Column header | Variable |
| --- | --- |
| sex | Sex of student (male = 0; female = 1) |
| DVRT | Vocal reasoning test score |
| fathocc | Prestige score of fathers occupation |
| lvcert | Taken leaving certificate (yes = 1; no = 0) |
| schltype | School type |

## GapMinder Dataset: *gapminderData5.csv*
| Column header | Variable |
| --- | --- |
| country | Country |
| year | Year |
| pop | Population |
| continent | Continent/Region |
| lifeExp | Life expectancy (yrs) |
| gdpPercap | Per Capita GDP (USD 2007) |


[1]: https://www.r-inla.org
[2]: https://cran.r-project.org/web/views/Bayesian.html
[3]: http://mc-stan.org